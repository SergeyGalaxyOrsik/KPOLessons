Процедура – участок кода, который может вызываться из различных мест программы
После выполнения процедуры управление возвращается в точку вызова

### Инструкция CALL
- выполняет вызов процедуры
	- записывает в стек ip на следующую инструкцию после call
	- выполняет безусловный переход по адресу, заданному операндом

### Инструкция RET
- извлекает из стека значение
- помещает его в регистр IP
Если есть операнд(необязательный):
- извлекает из стека значение (адрес возврата)
- извлекает из стека N-байт (N-операнд)
	- фактически - просто увеличивает значение SP
- помещает в регистр IP адрес возврата

```
call MyProc ; <---- вызывающий код

MyProc: ;
...     ; <------ вызываемый код
```
Важно, чтобы обе строки – вызывающая и вызываемая – соблюдали одно и то же соглашение вызова

Передача параметров:
- через регистры - (не очень круто)
- через память (глобальные переменные) - (лучше, но тоже такое себе)
- через стек - (просто лучший! просто лучший!)

Возврат значений:
- через регистры

Исходя из выше сказаного будем юзать ==передачу параметров через стек== и ==возврат значений функции через регистр==

-------------------------------
Пролог – часть процедуры, которая подготавливает процедуру к работе с параметрами

Эпилог – часть процедуры, которая восстанавливает состояние, необходимое для продолжения выполнения вызывающего кода

```
MyProc:
	push bp                   ;
	mov bp, sp                ; <-------- пролог
	sub sp, sizeof(localVars) ;
	...
	mov sp,bp                 ;
	pop bp                    ; <-------- эпилог
	ret sizeof(params)        ;
```

![[Screenshot 2024-05-31 at 23.59.47.png]]

Для приведённого кода состояние стека будет таким:
```
...
[bp+6] <---- параметр 2
[bp+4] <---- параметр 1
[bp+2] <---- адрес возврата
[bp]   <---- старые значения BP
[bp-2] <---- локальная переменная 1
[bp-4] <---- локальная переменная 2
```

## Далее [Соглашения вызова в assembly](<Соглашения вызова в assembly.md>)
